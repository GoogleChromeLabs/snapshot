'use strict';

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
}

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
const DB_VERSION = 2;
class ImageDB {
    constructor() {
        const request = indexedDB.open('image-db', DB_VERSION);
        this.dbPromise = new Promise((resolve, reject) => {
            this.dbResolve = resolve;
            this.dbReject = reject;
            request.onerror = reason => this.dbReject(reason);
            request.onupgradeneeded = event => this.createObjectStore(event);
            request.onsuccess = event => this.dbOpened(request);
        });
    }
    /**
     * Store an image in the database. If the `id` property of the record is not
     * set, this will create a new entry. Returns the ID of the record.
     */
    store(record) {
        const promise = new Promise((resolve, reject) => {
            this.dbPromise.then(db => {
                const transaction = db.transaction(['images'], 'readwrite');
                const put = transaction.objectStore('images').put(record);
                put.onsuccess = event => resolve(put.result);
                put.onerror = reject;
            }).catch(reject);
        });
        return promise;
    }
    retrieve(id) {
        const promise = new Promise((resolve, reject) => {
            this.dbPromise.then(db => {
                const transaction = db.transaction(['images'], 'readonly');
                const get = transaction.objectStore('images').get(id);
                get.onsuccess = event => resolve(get.result);
                get.onerror = reject;
            }).catch(reject);
        });
        return promise;
    }
    all() {
        const promise = new Promise((resolve, reject) => {
            this.dbPromise.then(db => {
                const transaction = db.transaction(['images'], 'readonly');
                const open = transaction.objectStore('images').openCursor();
                const results = [];
                open.onsuccess = event => {
                    const cursor = open.result;
                    if (cursor) {
                        results.push(cursor.value);
                        cursor.continue();
                    } else {
                        resolve(results);
                    }
                };
                open.onerror = reject;
            }).catch(reject);
        });
        return promise;
    }
    dbOpened(request) {
        this.dbResolve(request.result);
        this.dbPromise.then(db => {
            db.onerror = reason => this.error(reason);
        });
    }
    error(reason) {
        console.error(reason);
    }
    createObjectStore(event) {
        const request = event.target;
        const db = request.result;
        switch (event.oldVersion) {
            case 1:
                db.deleteObjectStore('images');
            case 0:
                db.createObjectStore('images', { keyPath: "id", autoIncrement: true });
        }
    }
}
var db = new ImageDB();
//# sourceMappingURL=image-db.js.map

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
class ViewState {}

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
class View {
    constructor(viewElement) {
        this.viewElement = viewElement;
    }
    show() {
        this.viewElement.classList.remove('hidden');
    }
    hide() {
        this.viewElement.classList.add('hidden');
    }
    getState() {
        return this.state || new ViewState();
    }
    setState(state) {
        this.state = state;
    }
}

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
class BrowseView extends View {
    constructor() {
        super(document.getElementById('browse-view'));
        this.captureButton = document.getElementById('browse-capture-button');
        this.uploadButton = document.getElementById('browse-upload-button');
        this.emptyListElement = document.getElementById('empty-browse-list');
        this.listElement = document.getElementById('browse-list');
        this.captureButton.addEventListener('click', () => this.captureClick());
        this.uploadButton.addEventListener('click', () => this.uploadClick());
        this.blobURLs = new Set();
    }
    show() {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            const photos = yield db.all();
            if (photos.length === 0) {
                this.emptyListElement.classList.remove('hidden');
                this.listElement.classList.add('hidden');
            } else {
                this.emptyListElement.classList.add('hidden');
                this.listElement.classList.remove('hidden');
                for (const record of photos) {
                    const thumb = document.createElement('div');
                    thumb.classList.add('element');
                    thumb.addEventListener('click', () => router.visit(`/edit/${record.id}`));
                    const blob = record.edited || record.original;
                    if (blob) {
                        const url = URL.createObjectURL(blob);
                        this.blobURLs.add(url);
                        thumb.style.backgroundImage = `url(${url})`;
                    }
                    this.listElement.appendChild(thumb);
                }
            }
            _super("show").call(this);
        });
    }
    hide() {
        super.hide();
        // TODO: Have a good think about this. The strategy here is to remove all
        // child elements when we hide, because smaller DOM seems like a win for the
        // rest of the app. But really we probably want a recycler instead...
        while (this.listElement.hasChildNodes()) {
            this.listElement.removeChild(this.listElement.lastChild);
        }
        for (const url of this.blobURLs) {
            URL.revokeObjectURL(url);
        }
        this.blobURLs.clear();
    }
    captureClick() {
        router.visit('/capture');
    }
    uploadClick() {
        router.visit('/upload');
    }
}

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
class ImageRecord {
    constructor(original) {
        this.original = original;
        this.edited = null;
    }
}

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
const streamConstraints = {
    audio: false,
    video: {
        deviceId: '',
        facingMode: ['user', 'environment'],
        height: { ideal: 1080 },
        width: { ideal: 1920 }
    }
};
class CaptureView extends View {
    constructor() {
        super(document.getElementById('capture-view'));
        this.videoElement = this.viewElement.querySelector('video#preview');
        this.videoElement2 = this.viewElement.querySelector('video#preview2');
        this.takePhotoButton = document.getElementById('capture-button');
        this.cameraChooseButton = document.getElementById('camera-choose-button');
        this.mirrorButton = document.getElementById('capture-mirror-button');
        this.closeButton = document.getElementById('capture-view-close');
        this.videoElement2.classList.add('hidden');
        this.takePhotoButton.addEventListener('click', () => this.takePhoto());
        this.cameraChooseButton.addEventListener('click', () => this.toggleCameraChooser());
        this.mirrorButton.addEventListener('click', () => this.toggleMirror());
        this.closeButton.addEventListener('click', () => this.close());
        this.devicesPromise = this.getDevices();
        this.currentDevice = null;
    }
    show() {
        this.devicesPromise.then(devices => {
            this.currentDevice = devices[0];
            this.startStream(this.currentDevice.deviceId);
        });
        super.show();
    }
    hide() {
        // TODO: Tear down video and stream
        if (this.capture) {
            this.capture.track.stop();
        }
        this.videoElement.pause();
        super.hide();
    }
    getDevices() {
        return __awaiter(this, void 0, void 0, function* () {
            let devices = yield navigator.mediaDevices.enumerateDevices();
            devices = devices.filter(device => device.kind === 'videoinput');
            if (devices.length < 2) {
                this.cameraChooseButton.classList.add('hidden');
            } else {
                this.cameraChooseButton.classList.remove('hidden');
            }
            return devices;
        });
    }
    takePhoto() {
        if (this.capture) {
            this.capture.takePhoto().then(blob => this.storeResult(blob));
        } else {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = this.videoElement.videoWidth;
            canvas.height = this.videoElement.videoHeight;
            context.drawImage(this.videoElement, 0, 0);
            canvas.toBlob(blob => this.storeResult(blob), 'image/jpg');
        }
    }
    toggleCameraChooser() {
        return __awaiter(this, void 0, void 0, function* () {
            // Four possible cases
            // 1. No camera! This view shouldn't even come up, we need a fallback UI
            // 2. One camera. Button should be hidden.
            // 3. Two cameras. Clicking button is a simple toggle.
            // 4. Three or more cameras. Present a chooser with the names and/or
            //    features of the cameras.
            // TODO: Need to change the button to reflect the kind of camera that will
            // be selected.
            const devices = yield this.devicesPromise;
            if (devices.length < 2) {
                return;
            }
            if (this.currentDevice) {
                const currentIndex = devices.indexOf(this.currentDevice);
                // TODO: Should show chooser for many devices, not just cycle
                this.currentDevice = devices[(currentIndex + 1) % devices.length];
            } else {
                this.currentDevice = devices[0];
            }
            this.startStream(this.currentDevice.deviceId);
        });
    }
    close() {
        router.visit(`/browse`);
    }
    storeResult(blob) {
        const record = new ImageRecord(blob);
        db.store(record).then(id => router.visit(`/edit/${id}`));
    }
    stopStream(stream) {
        for (const track of stream.getVideoTracks()) {
            track.stop();
        }
    }
    startStream(deviceId) {
        const current = this.videoElement.srcObject;
        if (current) {
            this.stopStream(current);
        }
        streamConstraints.video.deviceId = deviceId;
        navigator.mediaDevices.getUserMedia(streamConstraints).then(stream => {
            this.videoElement2.srcObject = stream;
            this.videoElement2.onloadedmetadata = () => {
                const temp = this.videoElement;
                this.videoElement = this.videoElement2;
                this.videoElement2 = temp;
                this.videoElement.play();
                this.videoElement.classList.remove('hidden');
                this.videoElement2.classList.add('hidden');
                this.videoElement2.pause();
            };
            if ('ImageCapture' in window) {
                const track = stream.getVideoTracks()[0];
                this.capture = new ImageCapture(track);
            }
        }).catch(reason => {
            // TODO: What to do if the user did not grant permission, etc?
        });
    }
    toggleMirror() {
        this.videoElement.classList.toggle('mirror');
    }
}

var fragmentShader = "\nprecision highp float;\nvarying vec2 texCoords;\nuniform sampler2D textureSampler;\nuniform vec2 sourceSize;\nuniform float saturation;\nuniform float warmth;\nuniform float sharpen;\nuniform float brightness;\nuniform float contrast;\nuniform float blur;\nuniform float vignette;\nuniform float grey;\nvec3 saturationVector = vec3(0.299, 0.587, 0.114);\nvoid main() {\n  vec2 off = sourceSize * blur;\n  vec2 off2 = off * 2.0;\n  vec4 tex00 = texture2D(textureSampler, texCoords + vec2(-off2.x, -off2.y));\n  vec4 tex10 = texture2D(textureSampler, texCoords + vec2(-off.x, -off2.y));\n  vec4 tex20 = texture2D(textureSampler, texCoords + vec2(0.0, -off2.y));\n  vec4 tex30 = texture2D(textureSampler, texCoords + vec2(off.x, -off2.y));\n  vec4 tex40 = texture2D(textureSampler, texCoords + vec2(off2.x, -off2.y));\n  vec4 tex01 = texture2D(textureSampler, texCoords + vec2(-off2.x, -off.y));\n  vec4 tex11 = texture2D(textureSampler, texCoords + vec2(-off.x, -off.y));\n  vec4 tex21 = texture2D(textureSampler, texCoords + vec2(0.0, -off.y));\n  vec4 tex31 = texture2D(textureSampler, texCoords + vec2(off.x, -off.y));\n  vec4 tex41 = texture2D(textureSampler, texCoords + vec2(off2.x, -off.y));\n  vec4 tex02 = texture2D(textureSampler, texCoords + vec2(-off2.x, 0.0));\n  vec4 tex12 = texture2D(textureSampler, texCoords + vec2(-off.x, 0.0));\n  vec4 tex22 = texture2D(textureSampler, texCoords + vec2(0.0, 0.0));\n  vec4 tex32 = texture2D(textureSampler, texCoords + vec2(off.x, 0.0));\n  vec4 tex42 = texture2D(textureSampler, texCoords + vec2(off2.x, 0.0));\n  vec4 tex03 = texture2D(textureSampler, texCoords + vec2(-off2.x, off.y));\n  vec4 tex13 = texture2D(textureSampler, texCoords + vec2(-off.x, off.y));\n  vec4 tex23 = texture2D(textureSampler, texCoords + vec2(0.0, off.y));\n  vec4 tex33 = texture2D(textureSampler, texCoords + vec2(off.x, off.y));\n  vec4 tex43 = texture2D(textureSampler, texCoords + vec2(off2.x, off.y));\n  vec4 tex04 = texture2D(textureSampler, texCoords + vec2(-off2.x, off2.y));\n  vec4 tex14 = texture2D(textureSampler, texCoords + vec2(-off.x, off2.y));\n  vec4 tex24 = texture2D(textureSampler, texCoords + vec2(0.0, off2.y));\n  vec4 tex34 = texture2D(textureSampler, texCoords + vec2(off.x, off2.y));\n  vec4 tex44 = texture2D(textureSampler, texCoords + vec2(off2.x, off2.y));\n  vec4 tex = tex22;\n  vec4 blurred = 1.0 * tex00 + 4.0 * tex10 + 6.0 * tex20 + 4.0 * tex30 + 1.0 * tex40\n               + 4.0 * tex01 + 16.0 * tex11 + 24.0 * tex21 + 16.0 * tex31 + 4.0 * tex41\n               + 6.0 * tex02 + 24.0 * tex12 + 36.0 * tex22 + 24.0 * tex32 + 6.0 * tex42\n               + 4.0 * tex03 + 16.0 * tex13 + 24.0 * tex23 + 16.0 * tex33 + 4.0 * tex43\n               + 1.0 * tex04 + 4.0 * tex14 + 6.0 * tex24 + 4.0 * tex34 + 1.0 * tex44;\n  blurred /= 256.0;\n  tex += (tex - blurred) * sharpen;\n  vec3 desaturated = vec3(dot(saturationVector, tex.rgb));\n  vec3 mixed = mix(desaturated, tex.rgb, saturation);\n  vec4 color = vec4(mixed, 1.0);\n  color.r += warmth;\n  color.b -= warmth;\n  vec4 gray = vec4(grey, grey, grey, 1.0);\n  color = mix(color * brightness, mix(gray, color, contrast), 0.5);\n  float ratio = off.x / off.y;\n  float dist = sqrt(pow(texCoords.x - 0.5, 2.0) + pow(ratio * (texCoords.y - 0.5), 2.0));\n  float vigCurve = exp(-pow(dist, 2.0) / (2.0 * pow(-vignette, 2.0)));\n  color *= vigCurve;\n  color.a = 1.0;\n  gl_FragColor = color;\n}\n";

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
const BASE_VERTEX_SHADER = `
attribute vec2 position;
attribute vec2 uv;

varying vec2 texCoords;

void main() {
  gl_Position = vec4(position, 0, 1.0);
  texCoords = uv;
}`;
const BASE_FRAGMENT_SHADER = `
precision highp float;

varying vec2 texCoords;

uniform sampler2D textureSampler;

void main() {
  gl_FragColor = texture2D(textureSampler, texCoords);
}`;
const POSITIONS = new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]);
const UVS = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);
const INDEX = new Uint16Array([0, 1, 2, 0, 2, 3]);
class ImageShader {
    constructor() {
        this.canvas = document.createElement('canvas');
        const context = this.canvas.getContext('webgl');
        if (context === null) {
            throw new Error(`Couldn't get a WebGL context`);
        }
        const gl = context;
        this.context = gl;
        const textureId = gl.createTexture();
        if (textureId === null) {
            throw new Error('Error getting texture ID');
        }
        this.textureId = textureId;
        this.programId = 0;
        this.vertShader = BASE_VERTEX_SHADER;
        this.fragShader = BASE_FRAGMENT_SHADER;
        this.uniformLocations = new Map();
        this.createVAO(INDEX, POSITIONS, UVS);
        gl.clearColor(1, 1, 1, 1);
        this.dirtyProgram = true;
    }
    setImage(image) {
        const gl = this.context;
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.textureId);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        // gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    }
    setVertexShader(source) {
        this.vertShader = source;
        this.dirtyProgram = true;
    }
    setFragmentShader(source) {
        this.fragShader = source;
        this.dirtyProgram = true;
    }
    setUniform(name, value) {
        const gl = this.context;
        if (this.dirtyProgram) {
            this.createProgram();
        }
        if (!this.uniformLocations.has(name)) {
            console.warn(`Tried to set unknown uniform ${name}`);
            return;
        }
        const info = this.uniformLocations.get(name);
        switch (info.type) {
            case gl.FLOAT:
                gl.uniform1fv(info.location, [value]);
                break;
            case gl.FLOAT_VEC2:
                gl.uniform2fv(info.location, value);
                break;
            case gl.FLOAT_VEC3:
                gl.uniform3fv(info.location, value);
                break;
            case gl.FLOAT_VEC4:
                gl.uniform4fv(info.location, value);
                break;
            case gl.BOOL:
            case gl.INT:
                gl.uniform1iv(info.location, [value]);
                break;
            case gl.BOOL_VEC2:
            case gl.INT_VEC2:
                gl.uniform2iv(info.location, value);
                break;
            case gl.BOOL_VEC3:
            case gl.INT_VEC3:
                gl.uniform3iv(info.location, value);
                break;
            case gl.BOOL_VEC4:
            case gl.INT_VEC4:
                gl.uniform4iv(info.location, value);
                break;
            default:
                console.error(`Couldn't set uniform, unsupported type`);
        }
    }
    render() {
        const gl = this.context;
        if (this.dirtyProgram) {
            this.createProgram();
        }
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        gl.flush();
    }
    createProgram() {
        const gl = this.context;
        const vertexShaderId = this.compileShader(this.vertShader, gl.VERTEX_SHADER);
        const fragmentShaderId = this.compileShader(this.fragShader, gl.FRAGMENT_SHADER);
        const programId = gl.createProgram();
        if (programId === null) {
            throw new Error(`Couldn't get a program ID`);
        }
        this.programId = programId;
        gl.attachShader(programId, vertexShaderId);
        gl.attachShader(programId, fragmentShaderId);
        gl.linkProgram(programId);
        if (!gl.getProgramParameter(programId, gl.LINK_STATUS)) {
            const info = gl.getProgramInfoLog(programId);
            throw new Error('Could not link shader program. \n\n' + info);
        }
        gl.validateProgram(programId);
        if (!gl.getProgramParameter(programId, gl.VALIDATE_STATUS)) {
            const info = gl.getProgramInfoLog(programId);
            throw new Error('Could not validate shader program. \n\n' + info);
        }
        gl.useProgram(programId);
        this.uniformLocations = new Map();
        this.getUniformLocations();
        this.dirtyProgram = false;
    }
    compileShader(source, type) {
        const gl = this.context;
        const shader = gl.createShader(type);
        if (shader === null) {
            throw new Error('Error creating shader');
        }
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            throw new Error(`Couldn't compiler shader: ${gl.getShaderInfoLog(shader)}`);
        }
        return shader;
    }
    getUniformLocations() {
        const gl = this.context;
        const numUniforms = gl.getProgramParameter(this.programId, gl.ACTIVE_UNIFORMS);
        for (let i = 0; i < numUniforms; i++) {
            const info = gl.getActiveUniform(this.programId, i);
            if (info === null) {
                throw new Error(`Couldn't get uniform info`);
            }
            const location = gl.getUniformLocation(this.programId, info.name);
            if (location) {
                this.uniformLocations.set(info.name, { type: info.type, location });
            }
        }
    }
    createVAO(index, positions, uvs) {
        const gl = this.context;
        const ext = gl.getExtension('OES_vertex_array_object');
        if (!ext) {
            throw new Error(`Browser doesn't support VAOs`);
        }
        const vaoId = ext.createVertexArrayOES();
        ext.bindVertexArrayOES(vaoId);
        this.bindIndicesBuffer(index);
        this.bindAttributeBuffer(0, 2, positions);
        this.bindAttributeBuffer(1, 2, uvs);
        gl.enableVertexAttribArray(0);
        gl.enableVertexAttribArray(1);
    }
    bindAttributeBuffer(attributeNumber, size, data) {
        const gl = this.context;
        const id = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, id);
        gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
        gl.vertexAttribPointer(attributeNumber, size, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    bindIndicesBuffer(data) {
        const gl = this.context;
        const id = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, id);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW);
    }
}

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
class EditView extends View {
    constructor() {
        super(document.getElementById('edit-view'));
        this.destElement = document.getElementById('edit-dest');
        this.closeButton = document.getElementById('edit-view-close');
        this.closeButton.addEventListener('click', () => this.closeClick());
        this.sliders = new Map();
        for (const slider of [...this.viewElement.getElementsByTagName('input')]) {
            this.sliders.set(slider.id, slider);
            slider.addEventListener('input', () => {
                if (!this.animationFrame) {
                    this.animationFrame = requestAnimationFrame(() => this.draw());
                }
            });
        }
        this.effectButtons = new Set(this.viewElement.querySelectorAll("button.effect-button"));
        for (const effectButton of this.effectButtons) {
            effectButton.addEventListener('click', () => this.effectButtonClick(effectButton));
        }
        this.imageShader = new ImageShader();
        this.imageShader.setFragmentShader(fragmentShader);
        this.destElement.appendChild(this.imageShader.canvas);
        this.currentPanel = null;
        this.currentRecord = null;
        this.pendingSave = false;
    }
    show() {
        const state = this.getState();
        if (!state.id) {
            // TODO: Better handling of errors?
            throw new Error(`Couldn't get id of image`);
        }
        this.imageElement = document.createElement('img');
        this.imageElement.onload = () => {
            URL.revokeObjectURL(this.imageElement.src);
            this.imageShader.setImage(this.imageElement);
            this.animationFrame = requestAnimationFrame(() => this.draw());
        };
        db.retrieve(state.id).then(record => {
            this.currentRecord = record;
            this.imageElement.src = URL.createObjectURL(record.original);
        });
        super.show();
    }
    hide() {
        cancelAnimationFrame(this.animationFrame);
        this.animationFrame = 0;
        this.currentRecord = null;
        if (this.currentPanel) {
            this.currentPanel.classList.add('hidden');
        }
        super.hide();
    }
    getState() {
        const state = super.getState();
        state.sliderValues = new Map();
        for (const [name, slider] of this.sliders) {
            state.sliderValues.set(name, Number(slider.value));
        }
        return state;
    }
    setState(state) {
        for (const [name, slider] of this.sliders) {
            slider.value = slider.defaultValue;
        }
        if (state.sliderValues) {
            for (const [name, value] of state.sliderValues) {
                if (this.sliders.has(name)) {
                    this.sliders.get(name).value = String(value);
                }
            }
        }
        super.setState(state);
    }
    draw() {
        const canvas = this.imageShader.canvas;
        canvas.width = this.imageElement.naturalWidth;
        canvas.height = this.imageElement.naturalHeight;
        this.imageShader.setUniform('sourceSize', new Float32Array([1 / canvas.width, 1 / canvas.height]));
        for (const [name, slider] of this.sliders) {
            const value = Number(slider.value) / 50;
            this.imageShader.setUniform(name, value);
        }
        this.animationFrame = 0;
        this.imageShader.render();
        this.triggerSave();
    }
    effectButtonClick(button) {
        const parent = button.parentElement;
        const panel = parent.querySelector('.slider-panel');
        if (this.currentPanel) {
            this.currentPanel.classList.add('hidden');
            if (this.currentPanel !== panel) {
                this.currentPanel = panel;
                panel.classList.remove('hidden');
            } else {
                this.currentPanel = null;
            }
        } else {
            this.currentPanel = panel;
            panel.classList.remove('hidden');
        }
    }
    triggerSave() {
        if (this.pendingSave) {
            return;
        }
        this.pendingSave = true;
        setTimeout(() => this.save(), 500);
    }
    save() {
        // TODO: Defer the toBlob call till after the rAF
        // BUG: crbug.com/752460
        this.pendingSave = false;
        this.draw();
        this.imageShader.canvas.toBlob(blob => {
            if (this.currentRecord) {
                this.currentRecord.edited = blob;
                db.store(this.currentRecord);
            }
        }, 'image/jpeg');
    }
    closeClick() {
        router.visit(`/browse`);
    }
}

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
class UploadView extends View {
    constructor() {
        super(document.getElementById('upload-view'));
        this.uploadInput = document.getElementById('upload-file-input');
        this.uploadButton = document.getElementById('upload-button');
        this.uploadDropTarget = document.getElementById('upload-drop-target');
        this.closeButton = document.getElementById('upload-view-close');
        this.uploadInput.addEventListener('change', () => this.inputChange());
        this.uploadButton.addEventListener('click', () => this.triggerUpload());
        this.uploadDropTarget.addEventListener('drop', e => this.dropHandler(e));
        this.uploadDropTarget.addEventListener('dragover', e => this.dragOverHandler(e));
        this.closeButton.addEventListener('click', () => this.close());
    }
    inputChange() {
        this.ingest(this.uploadInput.files);
    }
    triggerUpload() {
        this.uploadInput.click();
    }
    dragOverHandler(e) {
        e.stopPropagation();
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
    }
    dropHandler(e) {
        e.stopPropagation();
        e.preventDefault();
        this.ingest(e.dataTransfer.files);
    }
    ingest(files) {
        if (files.length === 0) {
            return;
        }
        const file = files[0];
        const record = new ImageRecord(file);
        db.store(record).then(id => router.visit(`/edit/${id}`));
    }
    close() {
        router.visit(`/browse`);
    }
}

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
class Router {
    constructor() {
        window.addEventListener('popstate', e => this.changeHandler(e.state));
        this.browseView = new BrowseView();
        this.captureView = new CaptureView();
        this.editView = new EditView();
        this.uploadView = new UploadView();
    }
    changeHandler(state) {
        // TODO: Not sure that I should take the state here
        // Ignore any changes in the hash.
        if (window.location.pathname === this.currentLocation) {
            return;
        }
        this.currentLocation = window.location.pathname;
        const parts = this.currentLocation.split('/');
        if (this.currentView) {
            this.currentView.hide();
        }
        if (!state) {
            state = new ViewState();
        }
        let newView = null;
        switch (parts[1]) {
            // TODO: In the final app, the view for / will probably be browse
            case '':
            case 'capture':
                newView = this.captureView;
                break;
            case 'browse':
                newView = this.browseView;
                break;
            case 'edit':
                newView = this.editView;
                state.id = Number(parts[2]);
                break;
            case 'upload':
                newView = this.uploadView;
                break;
            default:
                // TODO: Proper 404
                console.log('404');
        }
        if (newView) {
            this.switch(newView, state);
        } else {
            // TODO: Something better?
            console.log('Oh no, no view found!');
        }
    }
    switch(newView, state) {
        if (this.currentView) {
            this.currentView.hide();
        }
        newView.setState(state);
        newView.show();
        this.currentView = newView;
    }
    visit(url) {
        if (window.location.href === url) {
            return;
        }
        let state;
        if (this.currentView) {
            state = this.currentView.getState();
        }
        window.history.replaceState(state, '', window.location.href);
        window.history.pushState(null, '', url);
        this.changeHandler();
    }
    click(event) {
        const anchor = event.target;
        if (event.metaKey || event.ctrlKey || event.button !== 0) {
            return;
        }
        event.preventDefault();
        this.visit(anchor.href);
    }
}
var router = new Router();
//# sourceMappingURL=router.js.map

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js');
}
router.changeHandler();
//# sourceMappingURL=index.js.map
